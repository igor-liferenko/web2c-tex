--- ./6.1/web2c-6.1/web2c/tex/tex.web	1993-06-27 00:28:00.000000000 +0800
+++ ./7.0/web2c-7.0/web2c/tex.web	1995-03-21 14:05:32.000000000 +0700
@@ -42,6 +42,7 @@
 % Version 3.14 fixed unprintable font names and corrected typos (March 1991).
 % Version 3.141 more of same; reconstituted ligatures better (March 1992).
 % Version 3.1415 preserved nonexplicit kerns, tidied up (February 1993).
+% Version 3.14159 allowed fontmemsize to change; bulletproofing (March 1995).
 
 % A reward of $327.68 will be paid to the first finder of any remaining bug,
 % not counting changes introduced after August 1989.
@@ -183,7 +184,7 @@
 known as `\TeX' [cf.~Stanford Computer Science report CS1027,
 November 1984].
 
-@d banner=='This is TeX, Version 3.1415' {printed when \TeX\ starts}
+@d banner=='This is TeX, Version 3.14159' {printed when \TeX\ starts}
 
 @ Different \PASCAL s have slightly different conventions, and the present
 @!@:PASCAL H}{\ph@>
@@ -10675,7 +10676,7 @@
 @ Here now is the (rather formidable) array of font arrays.
 
 @d non_char==qi(256) {a |halfword| code that can't match a real character}
-@d non_address==font_mem_size {a spurious |font_index|}
+@d non_address=0 {a spurious |bchar_label|}
 
 @<Glob...@>=
 @!font_info:array[font_index] of memory_word;
@@ -10685,7 +10686,7 @@
 @!font_check:array[internal_font_number] of four_quarters; {check sum}
 @!font_size:array[internal_font_number] of scaled; {``at'' size}
 @!font_dsize:array[internal_font_number] of scaled; {``design'' size}
-@!font_params:array[internal_font_number] of halfword; {how many font
+@!font_params:array[internal_font_number] of font_index; {how many font
   parameters are present}
 @!font_name:array[internal_font_number] of str_number; {name of the font}
 @!font_area:array[internal_font_number] of str_number; {area of the font}
@@ -12305,6 +12306,7 @@
 @!lx:scaled; {extra space between leader boxes}
 @!outer_doing_leaders:boolean; {were we doing leaders?}
 @!edge:scaled; {left edge of sub-box, or right edge of leader space}
+@!glue_temp:real; {glue value before rounding}
 begin this_box:=temp_ptr; g_order:=glue_order(this_box);
 g_sign:=glue_sign(this_box); p:=list_ptr(this_box);
 incr(cur_s);
@@ -12387,16 +12389,25 @@
   cur_v:=base_line; dvi_h:=dvi_h+rule_wd;
   end
 
-@ @<Move right or output leaders@>=
+@ @d vet_glue(#)== glue_temp:=#;
+  if glue_temp>float_constant(1000000000) then
+           glue_temp:=float_constant(1000000000)
+  else if glue_temp<-float_constant(1000000000) then
+           glue_temp:=-float_constant(1000000000)
+
+@<Move right or output leaders@>=
 begin g:=glue_ptr(p); rule_wd:=width(g);
 if g_sign<>normal then
   begin if g_sign=stretching then
     begin if stretch_order(g)=g_order then
-      rule_wd:=rule_wd+round(float(glue_set(this_box))*stretch(g));
+      begin vet_glue(float(glue_set(this_box))*stretch(g));
 @^real multiplication@>
+      rule_wd:=rule_wd+round(glue_temp);
+      end;
     end
-  else  begin if shrink_order(g)=g_order then
-      rule_wd:=rule_wd-round(float(glue_set(this_box))*shrink(g));
+  else if shrink_order(g)=g_order then
+    begin vet_glue(float(glue_set(this_box))*shrink(g));
+      rule_wd:=rule_wd-round(glue_temp);
     end;
   end;
 if subtype(p)>=a_leaders then
@@ -12484,6 +12495,7 @@
 @!lx:scaled; {extra space between leader boxes}
 @!outer_doing_leaders:boolean; {were we doing leaders?}
 @!edge:scaled; {bottom boundary of leader space}
+@!glue_temp:real; {glue value before rounding}
 begin this_box:=temp_ptr; g_order:=glue_order(this_box);
 g_sign:=glue_sign(this_box); p:=list_ptr(this_box);
 incr(cur_s);
@@ -12551,11 +12563,14 @@
 if g_sign<>normal then
   begin if g_sign=stretching then
     begin if stretch_order(g)=g_order then
-      rule_ht:=rule_ht+round(float(glue_set(this_box))*stretch(g));
+      begin vet_glue(float(glue_set(this_box))*stretch(g));
 @^real multiplication@>
+      rule_ht:=rule_ht+round(glue_temp);
+      end;
     end
-  else  begin if shrink_order(g)=g_order then
-      rule_ht:=rule_ht-round(float(glue_set(this_box))*shrink(g));
+  else if shrink_order(g)=g_order then
+    begin vet_glue(float(glue_set(this_box))*shrink(g));
+    rule_ht:=rule_ht-round(glue_temp);
     end;
   end;
 if subtype(p)>=a_leaders then
@@ -14059,7 +14074,7 @@
   if f<0 then
     begin decr(n); f:=f+@'200000;
     end;
-  width(p):=mu_mult(width(p)); subtype(p):=normal;
+  width(p):=mu_mult(width(p)); subtype(p):=explicit;
   end;
 end;
 
@@ -16616,7 +16631,7 @@
 n\vert$. When hanging indentation is active, the left margin is
 |hang_indent|, if |hang_indent>=0|, else it is 0; the line length is
 $|hsize|-\vert|hang_indent|\vert$. The normal setting is
-|par_shape_ptr=null|, |hang_after=0|, and |hang_indent=1|.
+|par_shape_ptr=null|, |hang_after=1|, and |hang_indent=0|.
 Note that if |hang_indent=0|, the value of |hang_after| is irrelevant.
 @^length of lines@> @^hanging indentation@>
 
@@ -17962,7 +17977,7 @@
 
 @<Put the \(c)characters |hu[i+1..@,]| into |post_break(r)|...@>=
 minor_tail:=null; post_break(r):=null; c_loc:=0;
-if bchar_label[hf]<non_address then {put left boundary at beginning of new line}
+if bchar_label[hf]<>non_address then {put left boundary at beginning of new line}
   begin decr(l); c:=hu[l]; c_loc:=l; hu[l]:=256;
   end;
 while l<j do
@@ -22903,7 +22918,8 @@
   end;
 
 @ When a glue register or parameter becomes zero, it will always point to
-|zero_glue| because of the following procedure.
+|zero_glue| because of the following procedure. (Exception: The tabskip
+glue isn't trapped while preambles are being scanned.)
 
 @<Declare subprocedures for |prefixed_command|@>=
 procedure trap_zero_glue;
@@ -24033,7 +24049,7 @@
 undump_int(exten_base[k]);
 undump_int(param_base[k]);@/
 undump(min_halfword)(lo_mem_max)(font_glue[k]);@/
-undump(0)(font_mem_size)(bchar_label[k]);
+undump(0)(fmem_ptr-1)(bchar_label[k]);
 undump(min_quarterword)(non_char)(font_bchar[k]);
 undump(min_quarterword)(non_char)(font_false_bchar[k]);
 end
@@ -24285,6 +24301,8 @@
 var c:small_number; {0 for \.{\\end}, 1 for \.{\\dump}}
 begin c:=cur_chr;
 if job_name=0 then open_log_file;
+while input_ptr>0 do
+  if state=token_list then end_token_list@+else end_file_reading;
 while open_parens>0 do
   begin print(" )"); decr(open_parens);
   end;
@@ -24302,7 +24320,8 @@
     end;
   print(" was incomplete)");
   if_line:=if_line_field(cond_ptr);
-  cur_if:=subtype(cond_ptr); cond_ptr:=link(cond_ptr);
+  cur_if:=subtype(cond_ptr); temp_ptr:=cond_ptr;
+  cond_ptr:=link(cond_ptr); free_node(temp_ptr,if_node_size);
   end;
 if history<>spotless then
  if ((history=warning_issued)or(interaction<error_stop_mode)) then
@@ -24313,7 +24332,9 @@
   selector:=term_and_log;
   end;
 if c=1 then
-  begin @!init store_fmt_file; return;@+tini@/
+  begin @!init for c:=top_mark_code to split_bot_mark_code do
+    if cur_mark[c]<>null then delete_token_ref(cur_mark[c]);
+  store_fmt_file; return;@+tini@/
   print_nl("(\dump is performed only by INITEX)"); return;
 @:dump_}{\.{\\dump...only by INITEX}@>
   end;
